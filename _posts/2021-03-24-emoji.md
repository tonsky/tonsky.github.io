---
layout: post
title: "Emoji under the hood"
category: blog
summary: "Detailed look into all the machinery involved in rendering Emoji"
hackernews_id: 26574008
starred: true
---

<style>
  pre.large { font-size: 36px; line-height: 1.5em; background: transparent; margin: 0 -30px; }
</style>

_Translations: [Chinese](https://zhuanlan.zhihu.com/p/363950681) [Russian](https://habr.com/ru/company/itelma/blog/549366/)_

For the past few weeks, Iâ€™ve been implementing emoji support for [Skija](https://github.com/jetbrains/skija). I thought it might be fun sharing a few nitty-gritty details of how this â€œbiggest innovation in human communication since the invention of the letter ğŸ…°ï¸â€ works under the hood.

Warning: some emoji might not display as expected on your device. In that case, use this text version: Â¯\\\_(ãƒ„)\_/Â¯

# Intro to Unicode

As you might know, all text inside computers is encoded with numbers. One letterâ€”one number. The most popular encoding we use is called Unicode, with the two most popular variations called UTF-8 and UTF-16.

Unicode allocates 2Â²Â¹ (\~2 mil) characters called codepoints. Sorry, programmers, 21 is not a multiple of 8 ğŸ¤·. Out of those 2 million, actually defined are \~150k characters.

150k defined characters cover all the scripts used on ğŸŒ, many dead languages, a lot of weird stuff like ğ”£ğ”²ğ”«ğ”«ğ”¶ ğ•ğ•–ğ•¥ğ•¥ğ•–ğ•£ğ•¤, sÉ¹ÇÊ‡Ê‡Çl uÊop-Çpá´‰sdn, GHz as one glyph: ã“, â€œrightwards two-headed arrow with tail with double vertical strokeâ€: â¤˜, seven-eyed monster: ê™®, and a duck:

<figure>
  <img src="./duck.png" style="width: 482px;">
</figure>

As a side note, definitely check out [the Egyptian Hieroglyphs block](https://www.unicode.org/charts/PDF/U13000.pdf) (U+13000â€“U+1342F). They have some really weird stuff.

<figure>
  <img src="./egyptian.png">
</figure>

## Basic emoji

So, emoji. At their simplest, they are just that: another symbol in a Unicode table. Most of them are grouped in U+1F300â€“1F6FF and U+1F900â€“1FAFF.

<figure>
  <img src="./emoji_block.png">
</figure>

Thatâ€™s why emoji behave like any other letter: they can be typed in a text field, copied, pasted, rendered in a plain text document, embedded in a tweet, etc. When you type â€œAâ€, the computer sees U+0041. When you type â€œğŸŒµâ€, the computer sees U+1F335. Not much difference.

## Emoji fonts

Why are emoji rendered as images then? Well, bitmap fonts. Apparently, you can create a font that has pngs for glyphs instead of boring black-and-white vector shapes.

<figure>
  <img src="./apple_color_emoji.png">
</figure>

Every OS comes with a single pre-installed font for emoji. On macOS/iOS, thatâ€™s Apple Color Emoji. Windows has Segoe UI Emoji, Android has Noto Color Emoji.

As far as I can tell, Apple is a [bitmap font](https://docs.microsoft.com/en-us/typography/opentype/spec/cbdt) with 160Ã—160 raster glyphs, Noto uses 128Ã—128 bitmaps, and Segoe is a [vector color font](https://docs.microsoft.com/en-us/typography/opentype/spec/colr) ğŸ†’.

Thatâ€™s why emoji look different on different devicesâ€”just like fonts look different! On top of that, many apps bundle their own emoji fonts, too: WhatsApp, Twitter, Facebook.

<figure>
  <img src="./comparison.png">
</figure>

## Font fallbacks

Now about the rendering. You donâ€™t write your text in Apple Color Emoji or Segoe UI Emoji fonts (unless you are really young and pure at heart â¤ï¸). So how can a text set in e.g. Helvetica include emoji?

Well, with the same machinery that makes Cyrillic text look ugly in Clubhouse or on Medium: font fallbacks.

<figure>
  <img src="./cyrillics.png" style="height: 333px;">
</figure>

When you type, say, U+1F419, it is first looked up in your current font. Letâ€™s say itâ€™s San Francisco. San Francisco doesnâ€™t have a glyph for U+1F419, so OS starts to look for _any_ other installed font that might have it.

U+1F419 can only be found in Apple Color Emoji, thus OS uses it to render U+1F419 (rest of the text stays in your current font). In the end, you see ğŸ™. Thatâ€™s why, no matter which font you use, Emoji always look the same:

<figure>
  <img src="./fonts.png">
</figure>

## Variation selector-16

Not all Emoji started their life straight in Emoji code block. In fact, pictograms existed in fonts and Unicode at least since 1993. Look in Miscellaneous Symbols U+2600-26FF and Dingbats U+2700-27FF:

<figure>
  <img src="./misc.png">
</figure>

These glyphs are as normal as any other letters we use: they are single-codepoint, black-and-white, and many fonts have them included. For example, here are all the differnt fonts on my machine that have their own version of âœ‚ï¸ (U+2702 BLACK SCISSORS):

<figure>
  <img src="./black_scissors.png" style="height: 500px;">
</figure>

Guess what? When Apple Color Emoji was created, it had its own version of the same U+2702 codepoint that looked like this:

<figure>
  <img src="./scissors.png" style="height: 180px;">
</figure>

Now for the tricky part. How does OS knows when to render âœ‚ï¸ and when âœ‚ï¸, if both of them have the same codepoint and not only Apple Color Emoji has it, but also many other higher-priority traditional fonts?

Meet U+FE0F, also known as VARIATION SELECTOR-16. Itâ€™s a hint to the text renderer to switch to an emoji font.

<pre class="large">
U+2702 â€” âœ‚ï¸
U+2702 U+FE0F â€” âœ‚ï¸

U+2697 â€“ âš—ï¸
U+2697 U+FE0F â€“ âš—ï¸

U+26A0 â€“ âš›ï¸
U+26A0 U+FE0F â€“ âš›ï¸

U+2618 â€“ â˜˜ï¸
U+2618 U+FE0F â€“ â˜˜ï¸
</pre>

Simple, elegant, and no need to allocate new codepoints while the old ones are already there. After all, things like â˜ ï¸ and â˜ ï¸ have the same _meaning_, only the presentation is different.

## Grapheme clusters

Here we encounter another problem â€” our emoji are now not a single codepoint, but two. This means we need a way to define character boundaries.

Meet Grapheme Clusters. Grapheme cluster is a sequence of codepoints that is considered a single human-perceived glyph.

Grapheme Clusters were not invented just for emoji, they apply to normal alphabets too. â€œUÌˆâ€ is a single grapheme cluster, even though itâ€™s composed of two codepoints: U+0055 UPPER-CASE U followed by U+0308 COMBINING DIAERESIS.

Grapheme clusters create many complications for programmers. You canâ€™t just do `substring(0, 10)` to take the first 10 charactersâ€”you might split an emoji in half (or an acute, so donâ€™t do it anyway)!

Reversing a string is tricky, tooâ€”while U+263A U+FE0F makes sense, U+FE0F U+263A does not.

<figure>
  <img src="./reverse.png">
</figure>

Finally, you canâ€™t just call `.length` on a string. Well, you can, but the result will surprise you. If you a developer, try this <code style="white-space: nowrap;">"ğŸ¤¦ğŸ¼â€â™‚ï¸".length</code> in your browserâ€™s console.

A tip for programmers: if you are working with text, get a library that is grapheme clusters-aware. For C, C++m and JVM that would be [ICU](http://site.icu-project.org/), Swift does the right thing out-of-the-box, for others, see for yourself.

Grapheme clusters awareness month, anyone? Graphemes donâ€™t want to be split! Oh, who am I kidding? `for (int i = 0; i < str.length; ++i) str[i]` go brrr!

Oh, by the way, did I mentioned that this: Å²Ì·Ì¡Ì¡Ì¨Ì«ÍÌŸÌ¯Ì£ÍÍ“Ì˜Ì±Ì–Ì±Ì£ÍˆÍÌ«Í–Ì®Ì«Ì¹ÌŸÌ£Í‰Ì¦Ì¬Ì¬ÍˆÍˆÍ”Í™Í•Ì©Ì¬ÌÌÌŒÌ‰ÌÌ¾Í‘Ì’ÍŒÍŠÍ—ÌÌ¾ÌˆÌˆÌÌ†Ì…Ì‰ÍŒÌ‹Ì‡Í†ÌšÌšÌšÍ Í… is a single grapheme cluster, too? Its length is 65, and it shouldnâ€™t ever be split in half. Sleep tight ğŸ›Œ :)

## Skin tone modifier

Most human Emoji depict an abstract yellow person. When skin tone was added in 2015, instead of adding a new codepoint for each emoji and skin tone combination, only five new codepoints were added:  ğŸ»ğŸ¼ğŸ½ğŸ¾ğŸ¿ U+1F3FB..U+1F3FF.

These are not supposed to be used on their own but to be appended to the existing emoji. Together they form a ligature: ğŸ‘‹ (U+1F44B WAVING HAND SIGN) directly followed by ğŸ½ (U+1F3FD MEDIUM SKIN TONE MODIFIER) becomes ğŸ‘‹ğŸ½.

ğŸ‘‹ğŸ½ does not have its own codepoint (itâ€™s a sequence of two: U+1F44B U+1F3FD), but it has its own unique look. With just five modifiers, \~280 human emojis got turned into 1680 variations. Hereâ€™re some dancers:

<pre class="large" style="font-size: 64px;">ğŸ•ºğŸ•ºğŸ»ğŸ•ºğŸ¼ğŸ•ºğŸ½ğŸ•ºğŸ¾ğŸ•ºğŸ¿</pre>

## Zero-width Joiner

Letâ€™s say your friend just sent you a picture of an apple she is growing in her garden. You need to replyâ€”how? You might send a ğŸ‘© WOMAN EMOJI (U+1F469), followed by a ğŸŒ¾ SHEAF OF RICE (U+1F33E). If you put the two together: ğŸ‘©ğŸŒ¾, nothing happens. Itâ€™s just two separate emoji.

But! If you add U+200D in between, magic happens: they turn into the one ğŸ‘©â€ğŸŒ¾ woman farmer.

U+200D is called ZERO-WIDTH JOINER, or ZWJ for short. It works similarly to what we saw with skin tone, but this time you can join two self-sufficient emoji into one. Not all combinations work, but many do, sometimes in surprising ways!

Some examples:

<pre class="large">
ğŸ‘© + âœˆï¸ â†’ ğŸ‘©â€âœˆï¸
ğŸ‘¨ + ğŸ’» â†’ ğŸ‘¨â€ğŸ’»
ğŸ‘° + â™‚ï¸ â†’ ğŸ‘°â€â™‚ï¸
ğŸ» + â„ï¸ â†’ ğŸ»â€â„ï¸
ğŸ´ + â˜ ï¸ â†’ ğŸ´â€â˜ ï¸
ğŸ³ï¸ + ğŸŒˆ â†’ ğŸ³ï¸â€ğŸŒˆ
</pre>

One weird inconsistency Iâ€™ve noticed is that hair color is done via ZWJ, while skin tone is just modifier emoji with no joiner. Why? Seriously, I am asking you: why? I have no clue.

<pre class="large">
ğŸ‘¨ + ğŸ¿ U+1F3FF â†’ ğŸ‘¨ğŸ¿
ğŸ‘¨ + ZWJ + ğŸ¦° â†’ ğŸ‘¨â€ğŸ¦°
</pre>

Unfortunately, some emoji are NOT implemented as combinations with ZWJ. I consider those missing opportunities:

<pre class="large">
ğŸ‘¨ + ğŸ¦· â‰  ğŸ§›
ğŸ‘¨ + ğŸ’€ â‰  ğŸ§Ÿ
ğŸ‘© + ğŸ” â‰  ğŸ•µï¸â€â™€ï¸
ğŸ‘ + ğŸ‘ â‰  ğŸ‘€
ğŸ’„ + ğŸ‘„ â‰  ğŸ’‹
ğŸŒ‚ + ğŸŒ§ â‰  â˜”ï¸
ğŸ´ + ğŸŒˆ â‰  ğŸ¦„
ğŸš + ğŸŸ â‰  ğŸ£
ğŸˆ + ğŸ¦“ â‰  ğŸ…
ğŸ¦µ + ğŸ¦µ + ğŸ’ª + ğŸ’ª + ğŸ‘‚ + ğŸ‘‚ + ğŸ‘ƒ + ğŸ‘… + ğŸ‘€ + ğŸ§  â‰  ğŸ§
</pre>

How do you type ZWJ? You donâ€™t. But you can copy it from here: â€œ<span style="padding: 10px;">&#x200D;</span>â€. Note: this is a special character, so expect it to behave weird. Itâ€™s invisible, too. But itâ€™s there.

Another big area where ZWJ shines is families and relationships configuration. A short story to illustrate:

<pre class="large">
ğŸ‘¨ğŸ» + ğŸ¤ + ğŸ‘¨ğŸ¼ â†’  ğŸ‘¨ğŸ»â€ğŸ¤â€ğŸ‘¨ğŸ¼
ğŸ‘¨ + â¤ï¸ + ğŸ‘¨ â†’ ğŸ‘¨â€â¤ï¸â€ğŸ‘¨
ğŸ‘¨ + â¤ï¸ + ğŸ’‹ + ğŸ‘¨ â†’ ğŸ‘¨â€â¤ï¸â€ğŸ’‹â€ğŸ‘¨
ğŸ‘¨ + ğŸ‘¨ + ğŸ‘§ â†’ ğŸ‘¨â€ğŸ‘¨â€ğŸ‘§
ğŸ‘¨ + ğŸ‘¨ + ğŸ‘§ + ğŸ‘§ â†’ ğŸ‘¨â€ğŸ‘¨â€ğŸ‘§â€ğŸ‘§
</pre>

## Flags

Country flags are part of the Unicode standard, but for some reason are not implemented on Windows. If you are reading this in a browser from Windowsâ€”I am sorry!

Flags donâ€™t have dedicated codepoints. Instead, they are two-letter ligatures.

<pre class="large">
ğŸ‡º + ğŸ‡³ = ğŸ‡ºğŸ‡³
ğŸ‡· + ğŸ‡º = ğŸ‡·ğŸ‡º
ğŸ‡® + ğŸ‡¸ = ğŸ‡®ğŸ‡¸
ğŸ‡¿ + ğŸ‡¦ = ğŸ‡¿ğŸ‡¦
ğŸ‡¯ + ğŸ‡µ = ğŸ‡¯ğŸ‡µ
</pre>

They donâ€™t use real letters, though. Instead, the â€œregional indicator symbol letterâ€ alphabet is used (U+1F1E6..1F1FF). These letters are not used for anything but composing flags.

What happens if you put together two random letters? Not much: ğŸ‡½ğŸ‡¾ (except that text editing starts to behave strange).

If you want to experiment, feel free to copy and combine from this alphabet: ğŸ‡¦ ğŸ‡§ ğŸ‡¨ ğŸ‡© ğŸ‡ª ğŸ‡« ğŸ‡¬ ğŸ‡­ ğŸ‡® ğŸ‡¯ ğŸ‡° ğŸ‡± ğŸ‡² ğŸ‡³ ğŸ‡´ ğŸ‡µ ğŸ‡¶ ğŸ‡· ğŸ‡¸ ğŸ‡¹ ğŸ‡º ğŸ‡» ğŸ‡¼ ğŸ‡½ ğŸ‡¾ ğŸ‡¿. There are 258 valid two-letter combinations. Can you find them all?

A funny side-effect of being two-letter ligature: `''.join(reversed('ğŸ‡ºğŸ‡¦')) => 'ğŸ‡¦ğŸ‡º'`

## Tag Sequences

Two-letter ligatures are cool, but donâ€™t you want to be cooler? How about 32-letter ligatures? Meet tag sequences.

Tag sequence is a sequence of normal emoji, followed by another flavor of Latin letters (U+E0020..E007E), terminated with U+E007F CANCEL TAG.

Currently they are used for these three flags only: England, Scotland and Wales:

```
ğŸ´ + gbeng + E007F = ğŸ´ó §ó ¢ó ¥ó ®ó §ó ¿
ğŸ´ + gbsct + E007F = ğŸ´ó §ó ¢ó ³ó £ó ´ó ¿
ğŸ´ + gbwls + E007F = ğŸ´ó §ó ¢ó ·ó ¬ó ³ó ¿
```

## Keycaps

Not super-exciting, but needed for completeness: keycap sequences use yet another convention.

It goes like this: take a digit, * or #, turn it into emoji with U+FE0F, wrap into a square with U+20E3 COMBINING ENCLOSING KEYCAP:

<pre class="large">
* + FE0F + 20E3 = *ï¸âƒ£
</pre>

In total there are only twelve of them:

<pre class="large">
#ï¸âƒ£ *ï¸âƒ£ 0ï¸âƒ£ 1ï¸âƒ£ 2ï¸âƒ£ 3ï¸âƒ£ 4ï¸âƒ£ 5ï¸âƒ£ 6ï¸âƒ£ 7ï¸âƒ£ 8ï¸âƒ£ 9ï¸âƒ£
</pre>

## Unicode updates

Unicode is updated every year, and emoji are a major part of each release. E.g. in Unicode 13 (March 2020), 55 new Emoji were added.

At the moment of writing neither the latest macOS (11.2.3) nor iOS (14.4.1) support emoji from Unicode 13 like

<pre class="large">ğŸ˜®â€ğŸ’¨, â¤ï¸â€ğŸ”¥, ğŸ§”â€â™€ or ğŸ‘¨ğŸ»â€â¤ï¸â€ğŸ’‹â€ğŸ‘¨ğŸ¼</pre>

For future generations, this is what I see in March 2021:

<figure>
  <img src="./13.png">
</figure>

But, thanks to the magic of ZWJ, I can still figure out whatâ€™s going on, just not in the most optimal way.

## Conclusion

To sum up, these are seven ways emoji can be encoded:

1. A single codepoint `ğŸ§› U+1F9DB`
2. Single codepoint + variation selector-16 `â˜¹ï¸ U+2639 + U+FE0F = â˜¹ï¸`
3. Skin tone modifier `ğŸ¤µ U+1F935 + U+1F3FD = ğŸ¤µğŸ½`
4. Zero-width joiner sequence `ğŸ‘¨ + ZWJ + ğŸ­ = ğŸ‘¨â€ğŸ­`
5. Flags `ğŸ‡¦ + ğŸ‡± = ğŸ‡¦ğŸ‡±`
6. Tag sequences `ğŸ´ + gbsct + U+E007F = ğŸ´ó §ó ¢ó ³ó £ó ´ó ¿`
7. Keycap sequences `* + U+FE0F + U+20E3 = *ï¸âƒ£`

Techniques from 1-4 can be combined to construct a pretty complex message:

<pre>
  U+1F6B5 ğŸšµ Person Mountain Biking
+ U+1F3FB Light Skin Tone
+  U+200D ZWJ
+  U+2640 â™€ï¸Female Sign
+  U+FE0F Variation selector-16
= ğŸšµğŸ»â€â™€ï¸ Woman Mountain Biking: Light Skin Tone
</pre>

If you are a programmer, remember to always use the ICU library to:

- extract a substring,
- measure string length,
- reverse a string.

The keyword to google is â€œGrapheme Clusterâ€. It applies to emoji, to diacritics in Western languages, to Indic and Korean scripts, so please be aware.

Thatâ€™s all I have. I hope the deeper understanding of how emoji work under the hood will help you in your work... Nah, just kidding. Hope you enjoyed it, though âœŒï¸